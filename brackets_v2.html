<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Tournament Brackets</title>
  <style>
    :root {
      /* how far apart do you want your columns? */
      --round-gap: 100px;

      /* AUTO‑compute each connector as half the gap */
      --connector-length: calc(var(--round-gap) / 2);

      /* thickness stays the same */
      --connector-thickness: 2px;
    }

    .bracket-container {
      display: flex;
      gap: var(--round-gap);   /* <— this controls the column spacing */
    }

/* your SVG‑branch code already reads --connector-length and draws  */
    body {
      font-family: Arial, sans-serif;
      background: #f4f4f9;
      margin: 0;
      padding: 20px;
    }
    h1 { text-align:center; }

    /* wrapper around both the bracket and the SVG overlay */
    #bracketWrapper {
      position: relative;
      width: 100%;
      overflow: visible;
    }
    #svgConnectors {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
    }

    .bracket { margin-bottom: 50px; }
    .bracket h2 { text-align: center; }

    .bracket-container {
      display: flex;
      gap: var(--round-gap);
      justify-content: center;
    }
    .round {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .round h3 {
      margin-bottom: 10px;
    }

    .match, .champMatch {
      box-sizing: border-box;
      width: var(--match-width);
      height: var(--match-height);
      padding: var(--match-padding);
      margin: 30px 0;
      background: #ddd;
      border-radius: 5px;
      text-align: center;
      position: relative;
    }
    #svgConnectors {
      z-index: 0;
    }
    .match, .champMatch {
      position: relative;
      z-index: 1;
    }
  </style>
</head>
<body>

  <h1>All Brackets</h1>
  <div id="bracketWrapper">
    <svg id="svgConnectors"></svg>
    <div id="bracketContainer"></div>
  </div>

  <script>
    // — your existing data‑fetching helpers —
    function fetchBrackets() {
      return JSON.parse(localStorage.getItem("brackets") || "{}");
    }
    function fetchMatches() {
      return JSON.parse(localStorage.getItem("matches") || "[]");
    }

    document.addEventListener("DOMContentLoaded", () => {
      const bracketsData = fetchBrackets();
      const matches      = fetchMatches();
      const container    = document.getElementById("bracketContainer");
      const svg          = document.getElementById("svgConnectors");
      const wrapper      = document.getElementById("bracketWrapper");

      // 1) Render all the boxes
      Object.entries(bracketsData).forEach(([tierName, bracket]) => {
        const tierDiv = document.createElement("div");
        tierDiv.classList.add("bracket");
        tierDiv.innerHTML = `<h2>${tierName}</h2>`;

        const roundsDiv = document.createElement("div");
        roundsDiv.classList.add("bracket-container");

        bracket.roundMatchIds.forEach((roundIds, roundIdx) => {
          const rd = document.createElement("div");
          rd.classList.add("round");
          rd.innerHTML = `<h3>Round ${roundIdx+1}</h3>`;

          roundIds.forEach(id => {
            const m = matches.find(x => x.id === id) || {};
            const box = document.createElement("div");
            box.dataset.matchId = id;
            box.classList.add(m.nextMatch == null ? "champMatch" : "match");
            if (m.teamAID === m.teamBID) {
              box.textContent = m.teamAID || "TBD";
            } else {
              box.textContent = `${m.teamAID || "TBD"} vs ${m.teamBID || "TBD"}`;
            }
            rd.appendChild(box);
          });

          roundsDiv.appendChild(rd);
        });

        tierDiv.appendChild(roundsDiv);
        container.appendChild(tierDiv);
      });

      // 2) After layout, draw all branches
      requestAnimationFrame(drawBranches);

      function drawBranches() {
        // clear out any old lines
        svg.innerHTML = "";
        const ns = "http://www.w3.org/2000/svg";
        const L  = parseInt(getComputedStyle(document.documentElement)
                      .getPropertyValue("--connector-length"));

        // build id → element map
        const elMap = {};
        wrapper.querySelectorAll("[data-match-id]").forEach(el => {
          elMap[+el.dataset.matchId] = el;
        });

        // for each tier
        Object.values(bracketsData).forEach(bracket => {
          const rounds = bracket.roundMatchIds;

          // for each round except the last
          for (let r = 0; r < rounds.length - 1; r++) {
            const thisRound = rounds[r];
            const nextRound = rounds[r+1];

            // pair up every two matches
            for (let i = 0; i < thisRound.length; i += 2) {
              const id1 = thisRound[i];
              const id2 = thisRound[i+1];
              const nid = nextRound[i/2];

              const el1 = elMap[id1], el2 = elMap[id2], el3 = elMap[nid];
              if (!el1 || !el2 || !el3) continue;

              // get screen coords
              const b1 = el1.getBoundingClientRect();
              const b2 = el2.getBoundingClientRect();
              const b3 = el3.getBoundingClientRect();
              const W  = wrapper.getBoundingClientRect();

              const x1 = b1.right - W.left;
              const y1 = b1.top   - W.top + b1.height/2;
              const x2 = b2.right - W.left;
              const y2 = b2.top   - W.top + b2.height/2;
              const tx = b3.left  - W.left;
              const ym = (y1 + y2)/2;

              const branchX = tx + L;

              // draw horizontal from first match → branchX
              let line = document.createElementNS(ns,"line");
              line.setAttribute("x1", x1);
              line.setAttribute("y1", y1);
              line.setAttribute("x2", branchX);
              line.setAttribute("y2", y1);
              svg.appendChild(line);

              // draw horizontal from second match → branchX
              line = document.createElementNS(ns,"line");
              line.setAttribute("x1", x2);
              line.setAttribute("y1", y2);
              line.setAttribute("x2", branchX);
              line.setAttribute("y2", y2);
              svg.appendChild(line);

              // draw vertical trunk between them
              line = document.createElementNS(ns,"line");
              line.setAttribute("x1", branchX);
              line.setAttribute("y1", y1);
              line.setAttribute("x2", branchX);
              line.setAttribute("y2", y2);
              svg.appendChild(line);

              // draw horizontal from trunk midpoint → next match
              line = document.createElementNS(ns,"line");
              line.setAttribute("x1", branchX);
              line.setAttribute("y1", ym);
              line.setAttribute("x2", tx);
              line.setAttribute("y2", ym);
              svg.appendChild(line);

              // style all lines in one go
              svg.querySelectorAll("line").forEach(l => {
                l.setAttribute("stroke","#333");
                l.setAttribute("stroke-width",
                  getComputedStyle(document.documentElement)
                     .getPropertyValue("--connector-thickness"));
              });
            }
          }
        });
      }
    });
  </script>
</body>
</html>